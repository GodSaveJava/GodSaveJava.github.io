<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>树</title>
    <link href="/year/03/19/%E6%A0%91/"/>
    <url>/year/03/19/%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><br>&ensp;&ensp;我们知道，在利用树形查找时，树的高度会影响查找的效率。因此，在构建树的过程中，为了避免树的高度增长过快，降低二叉排序树的性能，我们通常会要求任意节点的左右子树高度之差(绝对值)不超过1。这样的树便被称为平衡二叉树，又名AVL树。<br><br>&ensp;&ensp;<strong>注意:平衡二叉树是特殊的二叉排序树!</strong></p><h2 id="平衡因子"><a href="#平衡因子" class="headerlink" title="平衡因子"></a>平衡因子</h2><p><br>&ensp;&ensp;左右子树高度之差，我们便称之为平衡因子，平衡二叉树的平衡因子只可能为-1 , 0 , 1。</p><h2 id="如何区分平衡与不平衡？"><a href="#如何区分平衡与不平衡？" class="headerlink" title="如何区分平衡与不平衡？"></a>如何区分平衡与不平衡？</h2><p><br>&ensp;&ensp;下面是一组平衡二叉树和非平衡二叉树的对比图:</p><p><img src="/img/Tree/1.jpg" alt="对比图" title="对比图"></p><p><br>&ensp;&ensp;在上图的非平衡二叉树中，节点2的左子树高度为3,右子树的高度为1,两边子树高度只差(平衡因子)的绝对值为2,超过了最大值1，因此这是一颗不平衡子树。而左边的平衡二叉树中的所有节点的平衡因子都不超过1。</p><h2 id="平衡二叉树的插入"><a href="#平衡二叉树的插入" class="headerlink" title="平衡二叉树的插入"></a>平衡二叉树的插入</h2><p><br>&ensp;&ensp;那么了解了AVL树的定义后，我们都能联想到一个问题:如果对AVL树进行插入操作的话，那是不是很有可能会破坏树的平衡状态?例如我在上图中的平衡二叉树中的第四层的叶子节点0下再插入一个节点，那么这棵树的平衡状态就会被破坏了，因为节点-1的左子树高度为1，而右子树的高度为3，平衡因子显然大于1。<br><br>&ensp;&ensp;那么有什么办法能够既能够插入数据，插入的数据不改变二叉排序树的性质，又不影响平衡二叉树的性质呢？很遗憾，是没有的。所以我们只能在插入数据后检查是否破坏了平衡性，若是不平衡的话则对最小不平衡树进行调整。(最小不平衡树:距离插入节点最近的，且平衡因子绝对值大于1的节点，以该节点为根节点构成的子树)。然而，在不同位置插入数据，所需要进行的调整也是不同的，调整的情况分为LL,LR,RL,RR。<br><img src="/img/Tree/2.jpg" alt="最小不平衡子树示意图" title="最小不平衡子树示意图"></p><h3 id="LL旋转-需要向右进行一次旋转"><a href="#LL旋转-需要向右进行一次旋转" class="headerlink" title="LL旋转 (需要向右进行一次旋转)"></a>LL旋转 (需要向右进行一次旋转)</h3><p><br>&ensp;&ensp;在最小不平衡子树中，由于在节点A的左(<strong>L</strong>)孩子的左(<strong>L</strong>)子树上插入了新节点导致失去了平衡，因此需要进行一次向右的旋转操作。<br><img src="/img/Tree/3.jpg" alt="LL旋转示意图" title="LL旋转示意图"><br><br>&ensp;&ensp;如图(节点旁的数字代表平衡因子):A的左孩子B向右上旋转代替A成为根节点，A向右下旋转成为B的右孩子，而B的原右子树则成为A的左子树。整个过程节点都是向右旋转，因此也叫做右旋。<br><br>&ensp;&ensp;这样调整的思路是，增高高度较小的一方子树，缩小高度较高的一方子树。如何缩小高度？通过增加节点的分支(由单分支变为双分支)，再通过调整节点的位置使得其符合二叉排序树(左&lt;根&lt;右)的性质。</p><h3 id="RR旋转-向左进行一次旋转"><a href="#RR旋转-向左进行一次旋转" class="headerlink" title="RR旋转(向左进行一次旋转)"></a>RR旋转(向左进行一次旋转)</h3><p><br>&ensp;&ensp;在最小不平衡子树中，由于节点A的右(<strong>R</strong>)孩子的右(<strong>R</strong>)子树上插入了新节点,导致以A为根节点的子树失去平衡，需要一次向左的旋转操作。<br><img src="/img/Tree/4.jpg" alt="RR旋转示意图" title="RR旋转示意图"><br><br>&ensp;&ensp;如图，将A的右孩子向左上旋转代替A成为根节点，将A向左下旋转成为B的左孩子，而B的原左子树则作为A的右子树。</p><h3 id="LR旋转-向左进行一次旋转后向右进行一次旋转"><a href="#LR旋转-向左进行一次旋转后向右进行一次旋转" class="headerlink" title="LR旋转(向左进行一次旋转后向右进行一次旋转)"></a>LR旋转(向左进行一次旋转后向右进行一次旋转)</h3><p><br>&ensp;&ensp;在最小不平衡子树中，由于节点A的左孩子(<strong>L</strong>)的右子树(<strong>R</strong>)插入了新的节点，导致以A节点为根的子树失去平衡，需要进行两次旋转操作，先向左旋转然后向右旋转。<br><img src="/img/Tree/5.jpg" alt="LR旋转示意图" title="LR旋转示意图"><br><br>&ensp;&ensp;如图，先将A的左孩子B的右子树的根节点C向左上旋转至B的位置，然后把节点C向上旋转提升到A的位置。</p><h3 id="RL旋转-先右旋后左旋"><a href="#RL旋转-先右旋后左旋" class="headerlink" title="RL旋转(先右旋后左旋)"></a>RL旋转(先右旋后左旋)</h3><p><br>&ensp;&ensp;在最小不平衡子树中，由于在A的右(<strong>R</strong>)孩子的左(<strong>L</strong>)子树上插入新的节点，导致以A节点为根的子树失去平衡，需要进行先右旋后左旋操作哦<br><img src="/img/Tree/6.jpg" alt="RL旋转示意图" title="RL旋转示意图"><br><br>&ensp;&ensp;先将A的右孩子B的左子树的根节点C向右旋转上升到B的位置，然后把C向左上旋转上升到A的位置</p><h3 id="如何记忆操作流程"><a href="#如何记忆操作流程" class="headerlink" title="如何记忆操作流程"></a>如何记忆操作流程</h3><p><br>&ensp;&ensp;总结的规律为:<br><br>&ensp;&ensp;&ensp;&ensp;(1)所有的操作都是和字母反着来的L的话就是右旋，R的话就是左旋<br><br>&ensp;&ensp;&ensp;&ensp;(2)LL和RR只需要重复的执行两次旋转操作就行，而LR和RL则是需要分别执行先右旋后左旋以及先左旋后右旋的操作<br><br>&ensp;&ensp;&ensp;&ensp;(3)先调整根节点的孩子，向上调整至根节点的位置。后调整根节点，向下调整至其孩子的位置。<br><br>&ensp;&ensp;&ensp;&ensp;(4)调整后，根节点A变为孩子节点，原根节点孩子方向上的子树调整为调整后的A的孩子，究竟是位于左孩子还是右孩子则取决于旋转时的方向(或根据二叉排序树:左&lt;根&lt;右的性质判断)。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构之查找算法</title>
    <link href="/year/03/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <url>/year/03/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h1><p>&ensp;&ensp;在数据集合中寻找某些关键字便谓之查找。而使用不同的算法效率也不一样。因此选择合适的查找算法至关重要。</p><h1 id="顺序查找-线性查找"><a href="#顺序查找-线性查找" class="headerlink" title="顺序查找(线性查找)"></a>顺序查找(线性查找)</h1><blockquote><p>最直观，最无脑的算法。从数据集的开头开始，逐渐向后遍历，一个一个的与需要查找的关键字进行对比，若不符合则继续遍历，直到找到匹配项。若遍历完后没有相应的匹配项，则证明该数据集中没有对应的元素。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SSTable</span>  <span class="hljs-comment">//假设有数据集SSTable,类型为结构体，包含元素elem和数据集的长度TableLen</span><br>&#123;<br><span class="hljs-type">int</span>* elem;<br><span class="hljs-type">int</span> TableLen;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Linear_Search</span><span class="hljs-params">(SSTable ST, <span class="hljs-type">int</span> key)</span>  <span class="hljs-comment">//ST为被查找的数据集，key为要查找的关键字</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; ST.TableLen;i++)   <span class="hljs-comment">//遍历数据集</span><br>&#123;<br><span class="hljs-keyword">if</span> (ST.elem[i] == key)   <span class="hljs-comment">//若是查找到匹配项，返回匹配项在数据集中的下标</span><br>&#123;<br><span class="hljs-keyword">return</span> i;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>你可以想象到，假如我们这个数据集的大小是10k个元素，而匹配项在数据集的最后一位的话，那么我们需要遍历整整10k遍才能得到最终的结果！！这无疑是低效的，是一个容易理解但很笨的算法，其时间复杂度在某些情况下是极其恐怖的。因此需要更聪明的算法。</p></blockquote><h1 id="折半查找-二分查找"><a href="#折半查找-二分查找" class="headerlink" title="折半查找(二分查找)"></a>折半查找(二分查找)</h1><blockquote><p>一个一个的查找实在是太蠢了，我们有没有更加聪明的办法?假如这个集合是有序的(例如是递增的)，那我们可以从数组的中间值开始查起。如果当前查找的值大于匹配项，则对这个集合的右半部分(以当前中间项为分界线)进行第二次折半查找….如此反复直到找到匹配值或无法找到匹配值。</p></blockquote><p>假设有一个递增的数组：[2,5,8,12,16,23,38,56,72,91]，并且想要找到数字 23。</p><p><img src="https://www.luigisbox.com/app/uploads/2023/05/binary-search-visualization.webp" alt="www.luigisbox.com" title="取自www.luigisbox.com"></p><p><br> ·在第一步中我们首先找到了该数组的中间值:16，我们发现中间值比我们要查找的关键字小，因此可以判断关键字存在于数组的右半部分(如果该数组里真有关键字的匹配项的话)。<br><br> ·第二步，在数组的右半部分中重复的使用折半查找:即将数组的右半部分看作一个完整的数组，找到它的中间值:56，发现起比关键值要大，因此判断匹配项可能在中间值的左边。<br><br> ·第三步，对中间值的左半部分重复使用折半查找，中间值为23，找到匹配项。</p><p><br> <em>因此我们可以看到，要使用这个算法，首先这个集合必须得是有序的！！有序的！！有序的！！如果拿到的是一个无序的集合则首先需要对他进行排序再使用该算法</em></p><blockquote><p>那么如何去实现对元素集的左&#x2F;右部分进行二分查找呢？我首先想到的是迭代&#x2F;递归，但无论是递归还是迭代都过于复杂了。因此还存在第三种选择，使用指针来实现.<br>  定义指针low,hight,mid，分别是指向当前要查找的部分的最低位，最高位和中间位。<br>  当关键字比中间位要大时，则对中间值的右半部分进行查找，此时low指针应该指向mid指针所指位置的下一位，然后将mid指针所指的位置重置为low和hight指针所指的区间的中间部分。<br>  当关键字比中间值要小时，则对中间值的左半部分进行查找，此时hight指针应该指向mid指针所知位置的上一位,然后类似的重置mid指针的位置。</p></blockquote><p> <img src="/img/Search/1.jpg" alt="示意图" title="示意图:取自王道考研数据结构 p280"></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arcade">int Binary_Search(SSTable ST, int key)<br>&#123;<br>int low = <span class="hljs-number">0</span>, hight = ST.TableLen - <span class="hljs-number">1</span>, <span class="hljs-built_in">mid</span>;<br><span class="hljs-keyword">while</span> (low &lt;= hight)  <span class="hljs-comment">//这里设置终止条件，如果hight指针出现在low指针前面，则说明该部分以及全部查找完了</span><br>&#123;<br><span class="hljs-built_in">mid</span> = (hight + low) / <span class="hljs-number">2</span>;  <span class="hljs-comment">//取中间值</span><br><span class="hljs-keyword">if</span> (ST.elem[<span class="hljs-built_in">mid</span>] == key)  <br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">mid</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; ST.elem[<span class="hljs-built_in">mid</span>])  <span class="hljs-comment">//关键字大于中间值，查找中间值的右半部分</span><br>&#123;<br>low = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span>  <span class="hljs-comment">//关键字小于中间值,查找中间值的左半部分</span><br>&#123;<br>hight = <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">//走完整个流程后仍未找到关键值，则返回0</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="树形查找"><a href="#树形查找" class="headerlink" title="树形查找"></a>树形查找</h1><h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><p>&ensp;&ensp;定义:任意一个节点:其左子树中每个节点的值均小于该节点，其右子树中的值均大于该节点。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gauss">   <span class="hljs-comment">//二叉排序树的结构:</span><br><span class="hljs-keyword">struct</span> <span class="hljs-type">BiTree</span><br>&#123;<br>int data;  <span class="hljs-comment">//当前节点的值</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">BiTree</span>* lchild;  <span class="hljs-comment">//当前节点的左孩子</span><br><span class="hljs-keyword">struct</span> <span class="hljs-type">BiTree</span>* rchile;  <span class="hljs-comment">//当前节点的右孩子</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><p><img src="/img/Search/2.jpg" alt="二叉排序树示意图" title="二叉排序树示意图"></p><p>&ensp;&ensp; 可以看到，从上面的排序树的任意一个非叶子节点出发，都符合左(当前选中节点的左子树中任意一个节点)&lt;中(当前选中节点)&lt;右的特性。</p><h2 id="二叉排序树的查找过程"><a href="#二叉排序树的查找过程" class="headerlink" title="二叉排序树的查找过程"></a>二叉排序树的查找过程</h2><p>&ensp;&ensp; 在二叉排序树的查找都是从根节点开始。若关键字的值大于根节点则在根节点的右子树上进行查找，若是小于则在左子树上进行查找。然后依次对比每个节点的值，若大于该节点则查其右子树，若小于则反之，直至查到匹配的关键字或是至叶子节点仍不匹配。<br><br>&ensp;&ensp; 以上图的二叉树为例:若是要查找值为4的节点，步骤依次是:<br> <br>   &ensp;&ensp; &ensp;&ensp; ●首先和根节点6进行比较，小于根节点，因此查找其左孩子<br> <br>   &ensp;&ensp; &ensp;&ensp; ●和左孩子2比较，大于该节点，因此查找其右孩子<br> <br>   &ensp;&ensp; &ensp;&ensp; ●找到匹配项4，查找成功。</p><h2 id="二叉排序树的构建"><a href="#二叉排序树的构建" class="headerlink" title="二叉排序树的构建"></a>二叉排序树的构建</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs xl">void BST_insert(Bit* T, int k) <span class="hljs-comment">//插入关键值</span><br>&#123;<br>Bit point = (Bit)malloc(sizeof(BiTree));  <span class="hljs-comment">//创建一个节点并初始化，并初始化:将值k赋给该节点的data部分，并将其左右孩子节点指向空</span><br><span class="hljs-function"><span class="hljs-title">point</span>-&gt;</span><span class="hljs-keyword">data</span> = k;<br><span class="hljs-function"><span class="hljs-title">point</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">lchild</span> = point-&gt;</span>rchile = NULL;<br><br><span class="hljs-keyword">if</span> (*T == NULL)  <span class="hljs-comment">//根节点为空，则直接将刚刚创建得到节点指定为根节点</span><br>&#123;<br>*T = point;<br>return;<br>&#125;<br>Bit Find_P = *T; <span class="hljs-comment">//创建一个指向根节点的指针，用于寻找这个节点对应位置的父节点</span><br><span class="hljs-keyword">while</span> (Find_P != NULL)<br>&#123;<br>F<span class="hljs-function"><span class="hljs-title">ind_P</span> = (Find_P-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span> &gt; k) ? Find_P-&gt;</span><span class="hljs-function"><span class="hljs-title">lchild</span> : Find_P-&gt;</span>rchile;  <span class="hljs-comment">//若该指针所指的节点的值大于要插入的关键值,该指针指向当前节点的左孩子，否则则相反。</span><br>&#125;<br><span class="hljs-comment">//当该层while循环执行完毕后，Find_P指针已经指向要插入节点的父节点</span><br><span class="hljs-function"><span class="hljs-title">if</span> (Find_P-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span> &gt; point-&gt;</span><span class="hljs-keyword">data</span>) <br>&#123;<br>F<span class="hljs-function"><span class="hljs-title">ind_P</span>-&gt;</span>lchild = point;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>F<span class="hljs-function"><span class="hljs-title">ind_P</span>-&gt;</span>rchile = point;<br>&#125;<br>&#125;<br><br>void Create_BiTree(Bit* T, int arry[], int n) &#123;  <span class="hljs-comment">//创建排序二叉树</span><br>T = NULL;<br>int i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i &lt; n)<br>&#123;<br>BST_insert(T, arry[i]);<br>i++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/Search/3.jpg" alt="二叉排序树构建示意图" title="二叉排序树构建示意图"></p><h2 id="效率分析"><a href="#效率分析" class="headerlink" title="效率分析"></a>效率分析</h2><p>&ensp;&ensp;二叉排序树的查找效率取决于树的高度。从查找过程看，二叉排序树就和二分查找相似，平均时间性能也差不多，但是二叉排序树的查找不唯一，相同的关键字可能会因为其插入的顺序不同而导致构建成的树也会不同。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>排序算法思想及实现</title>
    <link href="/year/03/03/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <url>/year/03/03/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><blockquote><p>算法思想是从长度为Length列表的第一个元素开始向后遍历，若相邻(当前遍历元素的右边)的元素的值小于当前<br/><br/><br>        遍历的元素，则交换两个数的位置，如此反复直到遍历至表尾，此时完成了第一轮遍历。反复执行Length-1轮<br/><br/><br>        时间复杂度: O(n²) 因为要执行两层循环<br/><br/><br>        空间复杂度: O(1) 不需要额外的空间<br/><br/><br>        优点: 好理解，不需要额外空间开销<br/><br/><br>        缺点: 慢，不适合处理大规模数据<br/><br/></p></blockquote><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">void <span class="hljs-keyword">Bubble_Sort(vector&lt;int&gt;&amp; </span>List)<br>&#123;<br>int <span class="hljs-keyword">swap;</span><br><span class="hljs-keyword"></span>for (int i = <span class="hljs-number">0</span><span class="hljs-comment">;i &lt; size(List) - 1;i++)</span><br>&#123;<br>for (int <span class="hljs-keyword">j </span>= <span class="hljs-number">0</span><span class="hljs-comment">;j &lt; size(List)-1;j++)</span><br>&#123;<br>if (List[<span class="hljs-keyword">j] </span>&gt; List[<span class="hljs-keyword">j+1])</span><br><span class="hljs-keyword"></span>&#123;<br><span class="hljs-keyword">swap </span>= List[<span class="hljs-keyword">j];</span><br>List[<span class="hljs-keyword">j] </span>= List[<span class="hljs-keyword">j+1];</span><br><span class="hljs-keyword"></span>List[<span class="hljs-keyword">j+1] </span>= <span class="hljs-keyword">swap;</span><br><span class="hljs-keyword"></span>&#125;<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><blockquote><p>&ensp;思想:<br/><br>  &ensp;将数据分为已排序和未排序两个部分，在开始前，已排序部分为空，未排序部分为整个数组</p><p>&ensp;此时从未排序的部分中找到最小的值，与未排序部分的第一个元素交换位置。交换后该位置便为已排序部分，未排序部分的起始位置向后移一位。如此反复逐渐扩大已排序部分的范围。</p><p>&ensp;例如:a&lt;b&lt;c&lt;d  ,有列表元素[c,a,d,b]<br/><br>&ensp;未排序(初始):c,a,d,b<br/><br>&ensp;交换位置:[a,c,d,b]<br/><br>  &ensp;已排序:a<br/><br>&ensp;未排序;c,d,b<br>….</p><p>&ensp;时间复杂度: 无论如何都是O(n²)，即使是初始便是有序的数组也要从头到尾执行一遍<br/><br>&ensp;空间复杂度: O(1)</p><p>&ensp;稳定性: 不稳定(相同大小不同前后顺序的元素，在排序后前后位置可能会发生改变)</p></blockquote><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Selection_Sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; list)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">size</span>(list)<span class="hljs-number">-1</span>;i++)<br>&#123;   <br><span class="hljs-type">int</span> min = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=i<span class="hljs-number">+1</span>;j&lt;<span class="hljs-built_in">size</span>(list);j++)<br>&#123;<br><span class="hljs-keyword">if</span> (list[j] &lt; list[min])<br>&#123;<br>min = j;<br>&#125;<br>&#125;<br><span class="hljs-built_in">swap</span>(list[i], list[min]);<br>&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><blockquote><p>思想:<br/><br>  &ensp;&ensp;将列表分为已排序和未排序两个部分，初始时已排序部分只有列表中的第一个元素，遍历未排序<br>的列表，将遍历的元素与已排序的部分中的元素进行对比，将其插入至已排序的部分中合适的位置</p><blockquote><p>值得一提的是，这个算法可能需要不断地插入和移动元素，因此用数组等形式并不方便，推荐使用链表，单双链表都可以</p></blockquote></blockquote><blockquote><p>最好时间复杂度: O(n)，列表有序，不需要移动<br/><br>  最坏时间复杂度: O(n²)<br><br>  平均: O(n²)<br>  <br><br><br>  空间复杂度: O(1)<br>  <br><br><br>  稳定性: 稳定算法</p></blockquote><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs xl">struct Arry_List<br>&#123;<br>int value;<br>struct Arry_List* next;<br>struct Arry_List* front;<br>&#125;;<br><br>void Insertion_Sort(Arry_List* head,int length)<br>&#123;   <br><span class="hljs-function"><span class="hljs-title">if</span> (head == NULL || head-&gt;</span>next == NULL) return; <span class="hljs-comment">// 处理空链表或单节点链表</span><br><br>Arry_List* Sort = head;<br>A<span class="hljs-function"><span class="hljs-title">rry_List</span>* Non_Sort = head-&gt;</span>next;<br>Arry_List* Swap;<br>    <br><span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>;i &lt; length;i++)<br>&#123;   <br>Sort = head;<br><span class="hljs-keyword">while</span> (Sort != Non_Sort)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">if</span> (Sort-&gt;</span><span class="hljs-function"><span class="hljs-title">value</span> &lt; Non_Sort-&gt;</span>value)<br>&#123;<br><br><span class="hljs-function"><span class="hljs-title">if</span> (Sort-&gt;</span>front != NULL) &#123;<br>S<span class="hljs-function"><span class="hljs-title">ort</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">front</span>-&gt;</span>next = Non_Sort;<br>&#125;<br>N<span class="hljs-function"><span class="hljs-title">on_Sort</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">front</span> = Sort-&gt;</span>front;<br>N<span class="hljs-function"><span class="hljs-title">on_Sort</span>-&gt;</span>next = Sort;<br>S<span class="hljs-function"><span class="hljs-title">ort</span>-&gt;</span>front = Non_Sort;<br>break;<br>&#125;<br>S<span class="hljs-function"><span class="hljs-title">ort</span> = Sort-&gt;</span>next;<br>&#125;<br>N<span class="hljs-function"><span class="hljs-title">on_Sort</span> = Non_Sort-&gt;</span>next;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><blockquote><p>希尔排序的实质就是将一个将一个数组按照希尔增量分成若干个子块，然后对子块进行排序。然后逐步缩小希尔增量，排序，反复执行直到增量为1<br/><br><br/>那么什么是希尔增量呢？希尔排序的特殊之处在于，划分小块的时候并不是与相邻的数为一块。比如说有数组[8 , 3 , 1 , 2 , 7 , 5 , 6 , 4],每隔4个数字为一组，得到小块[8 , 7],[3 , 5],[1 , 6],[2 , 4]。每个n个为一组，这里的n就叫做希尔增量。而希尔增量会在每次执行分割的时候的时候不断缩小，直到增量为1。<br><br/>让我们继续进行下去:对小块进行块内排序,得到[7 , 8],[3 , 5],[1 , 6],[2 , 4],此时的列表为:[7 , 3 , 1 , 2 , 8 , 5 , 6 ,4]<br>。</p><blockquote><p>这里值得一提的是，所谓的分小块只是在逻辑上我们将它分成了小块来处理，实际上列表并没有真正的被分为了几个小块，列表还是列表。</p></blockquote></blockquote><blockquote><p>在第二轮中，希尔增量变为2,那么组成的小块则为[7 , 1 , 8 , 6],[3 , 2 , 5 , 4]，进行块内排序后变为[1 , 6 ,7 , 8 ] ,[ 2 , 3, 4 , 5]那么排序后的列表变为[1 , 2, 6 , 3 , 7, 4 , 8 , 5]。<br><br>  第三轮中,希尔增量变为1,那么将整个列表都视为一个小块，对块内进行排序得到最终的列表[1 , 2 , 3 , 4 , 5 , 6 ,7 , 8]</p></blockquote><blockquote><p>由此可以看出，该算法的性能取决于希尔增量的选取，那么如何确定希尔增量呢？最原始的取法是取数组的长度的一半。也就是n &#x3D; length&#x2F;2,后续的排序中的增量则是n &#x3D; n &#x2F; 2。然而这并不是最优秀的取法，在后续的研究中还分别出现了Hibbard增量序列、Kunth增量序列、Sedgewick增量序列等等。然而在初始的学习中主要还是以学习排序的思想为主，因此增量序列默认区length&#x2F;2即可，若长度为奇数则会出现某一块的数量比其他几块要多一个数，也无伤大雅。</p><blockquote><p>另外块内排序的算法一般会选择简单插入排序。</p></blockquote></blockquote><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">/*算法的处理层次由高到低为:for : 希尔增量的值的变化</span><br><span class="hljs-comment">                             for : 根据希尔增量划分小组</span><br><span class="hljs-comment">                               for : 对每个小组内部的数据进行排序</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">void</span> Shell_Sort(vector&lt;<span class="hljs-built_in">int</span>&gt; Arry_List, <span class="hljs-built_in">int</span> List_size)<br>&#123;<br><span class="hljs-built_in">int</span> gap = List_size / <span class="hljs-number">2</span>; <span class="hljs-comment">//取得希尔增量</span><br><span class="hljs-keyword">for</span> (;gap &gt; <span class="hljs-number">0</span>;gap = gap / <span class="hljs-number">2</span>)  <span class="hljs-comment">//在每一轮排序完成后希尔增量需要缩小，并执行下一轮排序</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; gap;i++) <span class="hljs-comment">//希尔增量gap将数组逻辑上分为了几个小部分，该层每一轮循环的作用便是根据gap将数组分小组</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = i+gap;j &lt; List_size;j = j + gap) <span class="hljs-comment">//这里开始插入排序,+gap是为了实现逻辑上的分组，该层的循环是对每个小组进行组内排序.</span><br>&#123;   <br>    <span class="hljs-built_in">int</span> temp = Arry_List[j];<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = j - gap;<br><span class="hljs-keyword">if</span> (Arry_List[<span class="hljs-keyword">count</span>] &gt; Arry_List[j])<br>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-keyword">count</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; Arry_List[<span class="hljs-keyword">count</span>] &gt; temp)  <span class="hljs-comment">//将已排序部分中大于当前未排序的值的元素向后移</span><br>&#123;<br>Arry_List[<span class="hljs-keyword">count</span> + gap] = Arry_List[<span class="hljs-keyword">count</span>];  <span class="hljs-comment">//+gap是因为实际上数组并没有分为几个小组，只是逻辑上进行了分组</span><br><span class="hljs-keyword">count</span> = <span class="hljs-keyword">count</span> - gap;<br>&#125;<br>Arry_List[<span class="hljs-keyword">count</span> + gap] = temp;  <span class="hljs-comment">//最后将未排序的元素插入到合适的位置</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><blockquote><p>&ensp;&ensp;归并排序的思想和希尔排序有些类似，都是逻辑上将数组拆分成若干个小组，再对每个小组进行排序，然后再合成若干个更大的组，对更大的组进行排序。不同的是归并排序是对相邻的小组&#x2F;数据进行排序，而不是像希尔排序那样隔几个数据进行排序。</p><blockquote><p> &ensp;&ensp;例如在二路归并中，有数组:[49 , 38 , 65 , 97 , 76 , 13 , 27]<br>初始时将每一个元素分为一个小组:[49] [38] [65] [97] [76] [13] [27]<br><br/> &ensp;&ensp;第一趟归并后的小组为:[38 , 49] [65 , 97] [13 , 76] [27]  &#x2F;&#x2F;n路归并就是互相相邻的n个元素化为一小组。在这二路归并中则是指49,38为一组，65,97为一组等等…..然后再对组内进行排序<br><br> &ensp;&ensp;然后第二趟归并则是对第一趟归并得到的小组进行合并，排序，得到小组:[38 , 49 , 65 , 97] [13 , 27 , 76]<br><br> &ensp;&ensp;第三趟归并将其合并后再进行排序就得到一个完整的有序的列表<br><br> &ensp;&ensp;然而在排序的过程中，我们需要额外的空间来保存当前合并后并且排序了的元素，因此空间复杂度为:O(n)</p></blockquote></blockquote><blockquote><p><br> &ensp;&ensp;时间复杂度为:O(n log n)<br><br> &ensp;&ensp;优点:时间复杂度不算高，适合处理大规模数据<br><br> &ensp;&ensp;稳定性:稳定的算法<br><br> &ensp;&ensp;缺点:需要额外的空间<br>             &ensp;&ensp;对于小规模数据可能性能不如插入排序等简单算法</p></blockquote><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Merge_Sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; List,vector&lt;<span class="hljs-type">int</span>&gt;&amp; mergeList,<span class="hljs-type">int</span> front,<span class="hljs-type">int</span> end)</span> <span class="hljs-comment">//以二路归并为例（代码可能存在逻辑错误，仅供参考思路)，这里的mergeList是用于存储合并排序后的数组而开辟的额外空间</span></span><br><span class="hljs-function"></span>&#123;   <br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span>(List) / <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)  <span class="hljs-comment">//如果子列表只有一个元素，意味着已经分割完成，则可以跳出本层递归</span><br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">Left_List</span><span class="hljs-params">(List.begin() + front, List.begin() + size(List) / <span class="hljs-number">2</span>)</span></span>;  <span class="hljs-comment">/*将当前列表分割为左右两个部分，值得一提的是，vector数组定义时的begin和end是半开区间, 即vector[begin, end), 因此如果用这种方法来复制数组的话，</span><br><span class="hljs-comment">                                                                                 假如我想复制list的第1到10的元素到List中，则begin应该是1,end应该是11 */</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">Right_List</span><span class="hljs-params">(List.begin() + size(List)/<span class="hljs-number">2</span> , List.begin() + end)</span></span>;<br><span class="hljs-built_in">Merge_Sort</span>(Left_List,mergeList, <span class="hljs-number">0</span>, <span class="hljs-built_in">size</span>(Left_List));  <span class="hljs-comment">//递归的执行左半部分的分割</span><br><span class="hljs-built_in">merge</span>(mergeList, Left_List, Right_List);  <span class="hljs-comment">//(对于最初的List来说)左半部分的递归执行完毕后，数组将会被分割为单一的元素，然后执行merge函数来进行合并排操作</span><br><span class="hljs-built_in">Merge_Sort</span>(Right_List,mergeList,<span class="hljs-built_in">size</span>(Right_List) / <span class="hljs-number">2</span>, <span class="hljs-built_in">size</span>(Right_List));  <span class="hljs-comment">//同样的执行右半部分</span><br> <span class="hljs-built_in">merge</span>(mergeList, Left_List, Right_List);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; Merge_List,vector&lt;<span class="hljs-type">int</span>&gt; Left_List,vector&lt;<span class="hljs-type">int</span>&gt; Right_List)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (left != <span class="hljs-built_in">size</span>(Left_List) &amp;&amp; right != <span class="hljs-built_in">size</span>(Right_List))  <br>&#123;<br><span class="hljs-keyword">if</span> (Left_List[left] &gt; Right_List[right])<br>&#123;<br>Merge_List.<span class="hljs-built_in">push_back</span>(Right_List[right]);<br>right++;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>Merge_List.<span class="hljs-built_in">push_back</span>(Left_List[left]);<br>left++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (left == <span class="hljs-built_in">size</span>(Left_List)) <span class="hljs-comment">//左半部分已经排序完了，右半部分可能还有部分数据没有加入到Merge_List数组中</span><br>&#123;<br>Merge_List.<span class="hljs-built_in">insert</span>(Merge_List.<span class="hljs-built_in">end</span>(), Right_List.<span class="hljs-built_in">begin</span>() + right, Right_List.<span class="hljs-built_in">end</span>());<br>&#125;<br><span class="hljs-keyword">else</span>  <span class="hljs-comment">//同样的逻辑，相反排查</span><br>&#123;<br>Merge_List.<span class="hljs-built_in">insert</span>(Merge_List.<span class="hljs-built_in">end</span>(), Left_List.<span class="hljs-built_in">begin</span>() + left, Left_List.<span class="hljs-built_in">end</span>());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><blockquote><p> &ensp;&ensp; 快速排序的性能从其名字就能体现出来，这是一个综合情况来看最为快速的算法。<br/><br>   <br/> &ensp;&ensp; 快速排序的处理逻辑是:选择一个基准元素(一般是数组的开头或尾部或是中间部分)，遍历数组，大于该基准元素的移动至基准元素的右边，小于该基准元素的移动至数组的左边。然后对左右两部分的数继续递归处理，每一轮递归后基准元素都会处于正确的位置，递归完成后将会得到一个有序的数组。<br>   <br/> &ensp;&ensp; 逻辑上是如此，但在实现的时候我们就会发现这样排序是十分困难的，因为这涉及到数组元素频繁的移动，在某个地方插入元素会导致整个数组元素的后移，因此插入的思想是不适用于快速排序的。<br>   <br/> &ensp;&ensp; 因此我们可以借助指针，用两个指针分别指向队头和队尾(假设队头队尾指针分别为low,hight)，两个指针分别和基准元素进行对比:<br>   <br/> 将hight中元素和和基准元素比较:<br>    &ensp;&ensp;若是小于基准元素则将hight中的值复制到low所指的位置上，然后low指针后移(low++)<br>    &ensp;&ensp;若是大于基准元素,则hight前移(hight–)<br>   <br/>将low所指元素与基准元素进行比较:<br>   &ensp;&ensp;若是小于基准元素，则low后移(low++）<br>   &ensp;&ensp;若是大于基准元素，则将low所指元素复制到hight指针所指位置上，然后higth指针前移(hight–)<br>   <br>一直重复上述步骤，直到hight&#x3D;&#x3D;low，两个指针指向同一个位置时，该轮排序结束，将基准元素赋值到该位置。</p></blockquote><p>   <br/> &ensp;&ensp; 每轮递归的步骤就是:hight指针与基准元素对比,将值复制到low指针上(是否复制取决于大小关系)，low或hight指针移动。然后low指针与基准元素对比，复制值到hight指针上(取决于大小关系),low或hight指针移动。然后hight指针与基准元素对比…..如此循环至两指针重叠。<br>   <br>算法步骤可视化如下，取自:<a href="https://blog.csdn.net/SAMSARS/article/details/105332284">https://blog.csdn.net/SAMSARS/article/details/105332284</a><br>    <img src="/img/Sort/Fast_Sot.png" alt="算法可视化"></p><p>   <br/> &ensp;&ensp;时间复杂度: O(nlog n)<br>         &ensp;&ensp;空间复杂度:O(1)<br>         &ensp;&ensp;稳定性:不稳定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Quick_Sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; Arry,<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> hight)</span> <span class="hljs-comment">//该示例以数组第一个元素为基准元素</span></span><br><span class="hljs-function"></span>&#123;   <br><span class="hljs-keyword">if</span> (low &gt;= hight) <span class="hljs-comment">//若下次递归指针重叠，退出递归</span><br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> L = low;  <span class="hljs-comment">//保留原始左边界</span><br><span class="hljs-type">int</span> R = hight; <span class="hljs-comment">//原始右边界</span><br><span class="hljs-type">int</span> key = Arry[low]; <span class="hljs-comment">//基准值</span><br><span class="hljs-keyword">while</span> (low &lt; hight)    <br>&#123;<br><span class="hljs-keyword">if</span> (Arry[hight] &lt; key)  <span class="hljs-comment">//hight指针比较，交换</span><br>&#123;<br>Arry[low] = Arry[hight];<br>low++;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>hight--;<br>&#125;<br><span class="hljs-keyword">if</span> (Arry[low] &gt; key)  <span class="hljs-comment">//low指针比较。交换</span><br>&#123;<br>Arry[hight] = Arry[low];<br>hight--;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>low++;<br>&#125;<br>&#125;<br>Arry[low] = key;  <span class="hljs-comment">//退出while循环后此时low和hight重叠，那么重叠处便是基准值的正确位置</span><br><span class="hljs-built_in">Quick_Sort</span>(Arry, L, low - <span class="hljs-number">1</span>);  <span class="hljs-comment">//递归处理基准值的左半部分</span><br><span class="hljs-built_in">Quick_Sort</span>(Arry, low + <span class="hljs-number">1</span>, R);  <span class="hljs-comment">//递归处理基准值的右半部分</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><blockquote><p>&ensp;&ensp;个人认为较难理解的一个排序方式。首先要了解堆排序前我们需要了解二叉树的概念，以及什么是完全二叉树。<br><br>&ensp;&ensp;堆排序中的堆又分为大根堆和小根堆。对于大根堆的定义是:(1)最大的元素位于二叉树中根节点的位置，(2)子节点的值均小于其父节点的值。而小根堆则是相反。<br><img src="/img/Sort/Heap_Sort.jpg" alt="一个大根堆的示意图"><br><br>&ensp;&ensp;堆排序的思想是:将堆顶元素(也就是根节点)输出,将堆底元素(也就是一个二叉树中最底层，最后的一个叶节点)移至堆顶,此时这颗二叉树就不符合堆的性质了，这个时候就应该调整二叉树，使其符合大&#x2F;小根堆的定义，然后再重复的输出堆顶元素…..<br>    &ensp;&ensp;总结来说的步骤就是:建堆，输出，调整，输出，调整，输出…….直到所有的元素都被输出。<br>    &ensp;&ensp;那么要解决的问题就有两个:(1)如何根据给出的数组来建立一个堆?(2)如何将输出调整后的二叉树调整为一个符合定义的堆?<br><br>&ensp;&ensp;首先先来看看如何建堆，我们先从逻辑视角上来看:<br><br>&ensp;&ensp;我们先根据数组，将数组中的元素依次按照层次结构(从上到下，从左到右)的顺序组成一个二叉树<br><img src="/img/Sort/Heap_Sort.jpg" alt="一个大根堆的示意图"><br><br>&ensp;&ensp;然后开始调整二叉树的结构。从二叉树的最后一个子树开始(也就是最后一个节点，和其兄弟节点以及父节点组成的子树)。然后对他进行调整，看看根节点的值是否大于&#x2F;小于(取决于建立的是大根堆还是小根堆)其子节点的值，若不是则进行调整，交换根节点和子节点的位置。<br><img src="/img/Sort/1.png" alt="第一步"><br>    &ensp;&ensp;在逻辑上是如此，那么实际中该如何实现呢？计算机并没有一个真正的二叉树的图去寻找最后一个子树，那如何用算术表达式去找到最后的子树？<br>    &ensp;&ensp;对于n个节点的完全二叉树，其最后一个节点的父节点应该是第[n&#x2F;2]个节点(从左往右，从上至下数)。在上图中我们可以看到，此处一共有8个节点，那么第[8&#x2F;2&#x3D;4]个节点就是它的最小子树中的根节点，也就是最后一个节点的父节点。<br><br>&ensp;&ensp;此后，便依次向前对倒数第二、第三小…的子树进行调整，也就是以第([n&#x2F;2]-1～1）个节点为根的子树进行调整。<br><img src="/img/Sort/2.png" alt="完整的步骤"><br>    &ensp;&ensp;值得一提的是，在对该层子树进行调整时，可能会造成下一层的子树不符合堆的定义，破坏了堆的性质，因此还需要向下一级调整。<br><img src="/img/Sort/3.png" alt="破坏了堆的定义"><br>    &ensp;&ensp;在此处，当53与87进行交换后，我们发现，以53为根节点的子树的性质不符合大根堆的定义，因此还要再对下一级进行调整。此时建堆完毕。<br><br>&ensp;&ensp;建成堆后便开始对堆顶进行输出、调整工作。当输出堆顶元素后，我们将堆中最后一个元素移至堆顶，这无疑会破坏堆的性质，再将此时的二叉树重新调整为符合堆的定义的二叉树，重复输出，调整。<br>    &ensp;&ensp;以下是实例，引用王道考研2025数据结构第368页<br><img src="/img/Sort/4.jpg" alt="输出，调整"><br><br>&ensp;&ensp;那么就是如何去用代码实现了。首先我们要解决的问题是，父节点以及其子节点在数组中该如何表示？如上述例子中(假设实例中的数组为a[])，数组a[0]的左孩子是a[1],右孩子是a[2]，而当a[1]为根节点时，其左孩子为a[3],右孩子为a[4]。因此可以总结一个规律，在以及在以a[n]为根节点的二叉树中，其左右子节点分别为a[2n+1]和a[2n+2]。</p></blockquote><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">void</span> Heap_Build(<span class="hljs-type">int</span> Arry[], <span class="hljs-type">int</span> <span class="hljs-built_in">length</span>)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-built_in">length</span> / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i--)  <span class="hljs-comment">//找到所有子树的节点</span><br>&#123;<br>Heap_Sort(Arry, i, <span class="hljs-built_in">length</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-type">void</span> Heap_Sort(<span class="hljs-type">int</span> Arry[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> <span class="hljs-built_in">length</span>)  <span class="hljs-comment">//对子树进行调整的函数，此处的n传入的是子树的根节点</span><br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span> &lt; <span class="hljs-built_in">length</span>)  <span class="hljs-comment">//右孩子不为空</span><br>&#123;<br><span class="hljs-type">int</span> Case = (Arry[<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>] &gt; Arry[<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>]) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;  <span class="hljs-comment">//比较左右孩子节点，左&gt;右的话Case为1，否则Case为0</span><br><span class="hljs-keyword">switch</span> (Case) <br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:  <br><span class="hljs-keyword">if</span> (Arry[n] &lt; Arry[<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>])  <span class="hljs-comment">//这是以大根堆为例，若是小根堆则是&gt;，下面的if判断也是如此</span><br>&#123;<br><span class="hljs-type">int</span> temp = Arry[n];<br>Arry[n] = Arry[<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>];<br>Arry[<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>] = temp;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br><span class="hljs-keyword">if</span> (Arry[n] &lt; Arry[<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>])<br>&#123;<br><span class="hljs-type">int</span> temp = Arry[n];<br>Arry[n] = Arry[<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>];<br>Arry[<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>] = temp;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span>  <span class="hljs-comment">//右孩子为空(总不可能存在左孩子为空，但还会有右孩子的情况吧?)</span><br>&#123;<br><span class="hljs-keyword">if</span> (Arry[n] &lt; Arry[<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>])<br>&#123;<br><span class="hljs-type">int</span> temp = Arry[n];<br>Arry[n] = Arry[<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>];<br>Arry[<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>] = temp;<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习</title>
    <link href="/year/02/27/Linux%E5%AD%A6%E4%B9%A0/"/>
    <url>/year/02/27/Linux%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>首先要明白绝对路径和相对路径<br/><br>  绝对路径:相对于根目录的路径<br/><br>  相对路径:相对于当前目录的路径<br/><br>  <br/><br>  另外在输入时按tab键可以实现自动补全（若是有多个结果则会罗列出所有结果)</p></blockquote><h1 id="1-常用的指令"><a href="#1-常用的指令" class="headerlink" title="1.常用的指令:"></a>1.常用的指令:</h1><h2 id="1-1-pwd-打印路径"><a href="#1-1-pwd-打印路径" class="headerlink" title="1.1 pwd 打印路径"></a>1.1 pwd 打印路径</h2><p>   用于打印当前所在文件夹的路径</p><h2 id="1-2-cd-进入文件"><a href="#1-2-cd-进入文件" class="headerlink" title="1.2 cd 进入文件"></a>1.2 cd 进入文件</h2><p>   进入文件夹的指令:cd XXX</p><h2 id="1-3-mkdir-创建目录-make-directories"><a href="#1-3-mkdir-创建目录-make-directories" class="headerlink" title="1.3 mkdir 创建目录 -make directories"></a>1.3 mkdir 创建目录 -make directories</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在当前目录下创建XXX子目录</span><br>  <br>  <span class="hljs-built_in">mkdir</span> XXX<br><br><span class="hljs-comment"># 一次性创建多层目录</span><br>  <br>  <span class="hljs-built_in">mkdir</span> -p a/b/c<br><br><span class="hljs-comment"># 一次性创建多个目录</span><br>  <br>  <span class="hljs-built_in">mkdir</span> a b c<br></code></pre></td></tr></table></figure><h2 id="1-4-touch-创建文件"><a href="#1-4-touch-创建文件" class="headerlink" title="1.4 touch  创建文件"></a>1.4 touch  创建文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在当前目录下创建linux.txt文件</span><br><br>  <span class="hljs-built_in">touch</span> linux.txt<br><br><span class="hljs-comment"># 在上级目录下创建linux文件(创建与当前目录同级的文件)</span><br><br>  <span class="hljs-built_in">touch</span> ../linux<br><br><span class="hljs-comment"># 在home/bing/目录下创建linux文件(在指定路径下创建)</span><br><br>  <span class="hljs-built_in">touch</span> /home/bing/linux<br><br><span class="hljs-comment"># touch可用于创建多个文件，例如创建file file.txt两个文件(不指定文件后缀名则创建的是文件夹，指定后缀则是创建相应的文件)</span><br>  <br>  <span class="hljs-built_in">touch</span> file file.txt<br></code></pre></td></tr></table></figure><h2 id="1-5-ls-展现结构"><a href="#1-5-ls-展现结构" class="headerlink" title="1.5 ls 展现结构"></a>1.5 ls 展现结构</h2><p>  展现目录结构(当前目录所有的文件和文件夹)<br>  用例:<br/></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 展现当前目录</span><br>  <br>  <span class="hljs-built_in">ls</span>(也可写作: <span class="hljs-built_in">ls</span> ./)<br><br><span class="hljs-comment"># 展现上一级目录</span><br>  <br>  <span class="hljs-built_in">ls</span> ../<br><br><span class="hljs-comment"># 展现绝对路径</span><br>  <br>  <span class="hljs-built_in">ls</span> /home<br><br><span class="hljs-comment"># 展现根目录</span><br>  <span class="hljs-built_in">ls</span> /<br><br><span class="hljs-comment"># 列出指定路径下的文件/文件夹的名称，并以指定的格式进行显示</span><br>  语法:<span class="hljs-built_in">ls</span> 选项 路径<br>  <span class="hljs-built_in">ls</span> -lah /home<br>     解释:<br>         -l:表示list,表示以列表进行展示<br>         -a:表示显示所有的文件/文件夹（包含隐藏文件/文件夹)<br>         -h:表示以可读性较高的形式显示<br></code></pre></td></tr></table></figure><h2 id="1-6-rm-删除文件-目录"><a href="#1-6-rm-删除文件-目录" class="headerlink" title="1.6 rm 删除文件&#x2F;目录"></a>1.6 rm 删除文件&#x2F;目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 删除当前路径的文件</span><br>  <br>  <span class="hljs-built_in">rm</span> XXX<br><br><span class="hljs-comment"># 删除指定路径下的文件</span><br>  <br>  <span class="hljs-built_in">rm</span> /XX/XX/XXX<br><br><span class="hljs-comment"># 删除目录</span><br>  <br>  <span class="hljs-built_in">rm</span> -rf XXX<br>  <span class="hljs-built_in">rm</span> -rf /XX/XXX/XXX (支持绝对路径下删除)<br></code></pre></td></tr></table></figure><h2 id="1-7-cp-复制文件-文件夹到指定路径"><a href="#1-7-cp-复制文件-文件夹到指定路径" class="headerlink" title="1.7 cp 复制文件&#x2F;文件夹到指定路径"></a>1.7 cp 复制文件&#x2F;文件夹到指定路径</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 复制文件到指定路径</span><br>  语法: <span class="hljs-built_in">cp</span> 被复制的文件路径 文件被复制到的路径<br>  <br>  <span class="hljs-built_in">cp</span> /home/user/XXX  XXX/<br>  <br><span class="hljs-comment"># 复制文件夹到指定路径</span><br>  语法: <span class="hljs-built_in">cp</span> -r 被复制的文件夹路径 文件夹要复制到的路径<br> <br>  <span class="hljs-built_in">cp</span> -r XXX/ XXX/<br></code></pre></td></tr></table></figure><h2 id="1-8-mv-移动-重命名文件"><a href="#1-8-mv-移动-重命名文件" class="headerlink" title="1.8 mv 移动&#x2F;重命名文件"></a>1.8 mv 移动&#x2F;重命名文件</h2><blockquote><p>注意区分‘移动’和‘复制’的区别</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 移动文件</span><br>  语法: <span class="hljs-built_in">rm</span> 需要移动的文件的路径 移动的目的路径/<br>  <br>  <span class="hljs-built_in">rm</span> a b/<br>  <span class="hljs-built_in">rm</span> a ./  <span class="hljs-comment">#将路径a上的文件移动到根目录下</span><br><br><span class="hljs-comment"># 修改名称</span><br>  语法: <span class="hljs-built_in">rm</span> 文件名 文件名 <br><br>  <span class="hljs-built_in">rm</span> a b <span class="hljs-comment">#将当前文件夹下的文件a更名为b (注意:更名不需要输入路径，需先cd进入当前文件夹，才可对该文件夹下的文件进行更名操作)</span><br></code></pre></td></tr></table></figure><h1 id="使用vim及g-进行程序设计与编译"><a href="#使用vim及g-进行程序设计与编译" class="headerlink" title="使用vim及g++进行程序设计与编译"></a>使用vim及g++进行程序设计与编译</h1><h2 id="vim的使用"><a href="#vim的使用" class="headerlink" title="vim的使用 "></a>vim的使用 <br/></h2><blockquote><p>首先需要先cd进入对应的文件目录</p></blockquote><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vim"># 创建/打开文件<br>   <br>  <span class="hljs-keyword">vim</span> 文件名/文件路径(不预先<span class="hljs-keyword">cd</span>的话)   //终端会进入<span class="hljs-keyword">vim</span>编译器中，并且创建该文件，若该文件已存在则是打开该文件<br><br># 编写程序<br>   <br>  <span class="hljs-keyword">vim</span>编译器有分普通模式、末行模式和插入模式<br>  模式切换:<br>    <span class="hljs-number">1</span>.插入模式下按 Esc键进入普通模式<br>    <span class="hljs-number">2</span>.普通模式下输入 ：进入末行模式<br>    <span class="hljs-number">3</span>.插入模式和末行模式不能直接切换<br>  区别:<br>    普通模式主要操作：删除、复制、粘贴<br>    编辑模式主要操作：编辑文本<br>    末行模式主要操作：退出保存<br></code></pre></td></tr></table></figure><h2 id="vim-常用操作"><a href="#vim-常用操作" class="headerlink" title="vim 常用操作"></a>vim 常用操作</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-comment"># 在末行模式下:</span><br>  <span class="hljs-symbol">:w</span> 保存文件<br>    <br>  <span class="hljs-symbol">:q</span> 退出文件<br> <br>  <span class="hljs-symbol">:wq</span> 保存并退出文件<br> <br>  <span class="hljs-symbol">:w!</span> 强制保存文件<br> <br>  <span class="hljs-symbol">:q!</span>强制退出文件<br> <br>  <span class="hljs-symbol">:wq!</span> 强制保存并退出文件<br> <br>  <span class="hljs-symbol">:w</span> <span class="hljs-number">1</span>.txt 将文件另存到<span class="hljs-number">1</span>.txt <br> <br>  <span class="hljs-symbol">:</span><span class="hljs-number">1</span>,<span class="hljs-number">3</span> w <span class="hljs-number">1</span>.txt 将<span class="hljs-number">1</span><span class="hljs-number">-3</span>行内容另存到<span class="hljs-number">1</span>.txt  <br> <br>  <span class="hljs-symbol">:r</span> <span class="hljs-number">2</span>.txt 将<span class="hljs-number">2</span>.txt文件内容写入到该文件光标所在行中<br> <br>  <span class="hljs-symbol">:</span><span class="hljs-number">5</span> r <span class="hljs-number">2</span>.txt 将<span class="hljs-number">2</span>.txt文件内容写入到该文件第<span class="hljs-number">5</span>行后<br></code></pre></td></tr></table></figure><h2 id="使用g-编译文件"><a href="#使用g-编译文件" class="headerlink" title="使用g++编译文件"></a>使用g++编译文件</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 编译操作</span><br>  <br>  g++ 文件名<span class="hljs-params">(带后缀)</span> -o 输出的文件名  <span class="hljs-string">//</span>执行后在相应的路径下生成一个可执行文件<br><br><span class="hljs-comment"># 执行文件</span><br>  可以用<span class="hljs-keyword">ls</span>查看当前目录下的文件，绿色文件名的文件即为可执行文件<br>   <br>  <span class="hljs-string">./</span>可执行文件名  <span class="hljs-string">//</span>这里的<span class="hljs-string">./</span>表示当前目录<br><br><span class="hljs-comment"># 编译带调试信息的·1可执行文件</span><br><br>  g++ -g 文件名 -o 输出文件名  <span class="hljs-string">//</span>产生能被GDB使用的调试信息，以调试程序<br><br><span class="hljs-comment"># 指定编译标准</span><br><br>  g++ -std=标准 文件名<br>  例 g++ -std=c++11 xxx.cpp<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>&#39;算法学习&#39;</title>
    <link href="/year/02/09/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/year/02/09/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本篇用于记录刷力扣时值得参考的算法题，主语言为C++</p></blockquote><h2 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历  "></a>二叉树的中序遍历  <br/></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++">**<br> * Definition <span class="hljs-keyword">for</span> a binary tree node.<br> * <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br> *     <span class="hljs-type">int</span> val;<br> *     TreeNode *left;<br> *     TreeNode *right;<br> *     <span class="hljs-built_in">TreeNode</span>() : <span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br> *     <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br> *     <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x, TreeNode *left, TreeNode *right) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(left), <span class="hljs-built_in">right</span>(right) &#123;&#125;<br> * &#125;;<br> */<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root,vector&lt;<span class="hljs-type">int</span>&gt;&amp; res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)<br>        &#123;<br>            <span class="hljs-keyword">return</span>; <span class="hljs-comment">//当前节点为空的话跳出该次递归</span><br>        &#125;<br>        <span class="hljs-built_in">inorder</span>(root-&gt;left,res); <span class="hljs-comment">/*递归调用，将root指针指向当前节点的左子节点。当遇到最左边的子节点时</span><br><span class="hljs-comment">                                  再执行inorder的话，此时root指针会指向空，此时便会触发上面的if判断，</span><br><span class="hljs-comment">                                  跳出该次递归，返回上一层的递归。那么此时root便指向了最靠左的子节点</span><br><span class="hljs-comment">                                 */</span><br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val); <span class="hljs-comment">//root指针指向最左子节点后，将该节点的值压入容器res中</span><br>        <span class="hljs-built_in">inorder</span>(root-&gt;right,res); <span class="hljs-comment">//若该最左子节点他还有个右孩子的话，root便会指向它，再次执行上边的流程</span><br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>           vector&lt;<span class="hljs-type">int</span>&gt; res;  <span class="hljs-comment">//定义一个空的vector容器res</span><br>           <span class="hljs-built_in">inorder</span>(root,res);  <span class="hljs-comment">//从根节点开始执行递归</span><br>           <span class="hljs-keyword">return</span> res;   <span class="hljs-comment">//最后返回一个包含中序遍历的结果的res</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h2><blockquote><p>我觉得利用递归来建树这个思想很值得学习</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;<br>          <span class="hljs-keyword">if</span>(root1==<span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">//if用于判断是否到达叶节点，到达后跳出该层递归，返回上层节点。</span><br>                              <span class="hljs-comment">//还有一个作用是当A树的该节点为空，B树的该节点非空时,null + value = value，所以直接返回非空节点的值 </span><br>          &#123;<br>            <span class="hljs-keyword">return</span> root2;  <br>          &#125;<br>          <span class="hljs-keyword">if</span>(root2==<span class="hljs-literal">nullptr</span>)<br>          &#123;<br>            <span class="hljs-keyword">return</span> root1;<br>          &#125;<br>          <span class="hljs-keyword">auto</span> merged = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(root1-&gt;val + root2-&gt;val);  <span class="hljs-comment">//新建一个新节点，用于储存两个树的节点相加后的值</span><br>          merged-&gt;left = <span class="hljs-built_in">mergeTrees</span>(root1-&gt;left,root2-&gt;left);  <span class="hljs-comment">/*建立左子树部分，并且利用递归的方式创建左孩子的孩子节点</span><br><span class="hljs-comment">                                                                理解这一部分的递归调用很关键 */</span><br>          merged-&gt;right = <span class="hljs-built_in">mergeTrees</span>(root1-&gt;right,root2-&gt;right);<br>          <span class="hljs-keyword">return</span> merged;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结来说的运行逻辑是这样的:<br/><br>      创建一个merged节点(类型为结构体TreeNode,包含了val和left、right的指针)(这里的auto也很有意思，可以去了解一下)<br>      <br/>merged节点的值等于root1的值+root2的值<br>      <br/>目光聚焦到merged节点的左孩子,怎么得到它的值？再执行一遍mergeTrees函数！不过此时函数中的参数应该设置为root1,root2的左孩子<br>      <br/>如果还没到叶节点，那么这个递归会一直进行下去<br>      <br/>若到达了叶节点，说明这颗合成树的root-&gt;left-&gt;left-&gt;left……依旧构造完了<br>      <br/>叶子节点弹出递归栈，返回它的父节点，如果此时父节点的右孩子为非空的话，继续执行merged-&gt;right的递归<br>      <br/>反复的弹出递归栈…执行merged-&gt;right…….<br>      <br/></p></blockquote><blockquote><p>理解递归栈的调用和程序的执行顺寻很重要，比如执行递归调用时，当前的程序在什么位置？执行递归调用的话会回到什么位置？执行完递归后又会回到什么位置？这段代码会有助于理解递归栈的调用逻辑</p></blockquote><h2 id="for循环的简化"><a href="#for循环的简化" class="headerlink" title="for循环的简化"></a>for循环的简化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;prices.<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(prices[i]&lt;minbuy)<br>        &#123;<br>            minbuy = prices[i];  <span class="hljs-comment">//找到最小值</span><br>        &#125;<br>        profit = prices[i] - minbuy;<br>        <span class="hljs-keyword">if</span>(profit&gt;maxprofit)<br>        &#123;<br>            maxprofit = profit;  <span class="hljs-comment">//找到最大值</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>看起来就很冗余，可以用 : 来代替for循环中的条件，并且最大最小值可与用max(a,b),min(a,b)来完成</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:prices) <span class="hljs-comment">//等于:for(int j = 0;j&lt;prices.size();j++)    i = price[j]</span><br>   &#123;   <br>       minbuy = <span class="hljs-built_in">min</span>(minbuy,i);  <span class="hljs-comment">//比if判断要简洁多了</span><br>       maxprofit = <span class="hljs-built_in">max</span>(maxprofit,i-minbuy);<br>     <br>   &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>&#39;CS61A学习历程（2）&#39;</title>
    <link href="/year/01/26/CS61A%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B%EF%BC%882%EF%BC%89/"/>
    <url>/year/01/26/CS61A%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B%EF%BC%882%EF%BC%89/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CS61A 学习历程</title>
    <link href="/year/01/24/CS61A-%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/"/>
    <url>/year/01/24/CS61A-%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="范围-range"><a href="#范围-range" class="headerlink" title="范围(range)"></a>范围(range)</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code class="hljs">range(startNum,endNum-1)</code></pre><blockquote><p><em>是的，这看起来有些奇怪,但请切记endNum-1这一回事!!<br/>如果你想要范围1~10的话，请输入:range(1,11)而不是range(1,10)!!!</em></p></blockquote><p>例如:  </p><pre><code class="hljs">in put :         range(1,3)out put :   [1,2]</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="range可以搭配数组一起使用"><a href="#range可以搭配数组一起使用" class="headerlink" title="range可以搭配数组一起使用:"></a>range可以搭配数组一起使用:</h4><pre><code class="hljs">   odd = [2,4,6,8,10,12]in put :  [odd[i] for i in  range(1,3)]   //或是  odd[1:3]</code></pre><blockquote><p>这里提到了for的一个用法，该语句意思是依次提取列表odd中第i个值，i的值分别是范围1~2(即提取odd[1],odd[2])<br/>另外，记得列表是从第0个开始的</p></blockquote><pre><code class="hljs">out put:  [4,6]</code></pre><h4 id="搭配函数使用"><a href="#搭配函数使用" class="headerlink" title="搭配函数使用:"></a>搭配函数使用:</h4><pre><code class="hljs">in put:   max(range(5)) 等同于 max(0,1,2,3,4)out put:    4这里提到了max函数,还有个更好玩的特性：in put:    max(range(10),key = lamba x: 7 -(x-4)*(x-2))      //意思是x的取值范围为0~9,key等于关于x的表达式7 -(x-4)*(x-2)，x取所有范围的值计算后的最大值    //(lamba x: 7 -(x-4)*(x-2)) (3) = 8    //(lamba x: 7 -(x-4)*(x-2)) (2) = 7    //(lamba x: 7 -(x-4)*(x-2)) (4) = 7out put:    3</code></pre><h3 id="一些特性"><a href="#一些特性" class="headerlink" title="一些特性"></a>一些特性</h3><p>若不声明startNum,则默认为从0开始</p><p>若不声明endNum,则默认范围至末尾为止</p><pre><code class="hljs">in put :  odd[1:3]  odd[:3]  odd[1:]  odd[:]out put:  [4,6]  [2,4,6]  [4,6,8,10,12]  [2,4,6,8,10,12]</code></pre><h1 id="判断-bool"><a href="#判断-bool" class="headerlink" title="判断(bool)"></a>判断(bool)</h1><p>   和其他语言类似，具体用法不再赘述，值得一提的是，Py里bool函数有些有趣的用法:</p><pre><code class="hljs"> in put:    [x&lt;5 for x in range(5)]    [x&lt;4 for x in range(5)] out put:     [ture,ture,ture,ture,ture,ture]     [ture,ture,ture,ture,ture,false]</code></pre><h1 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串(string)"></a>字符串(string)</h1><p>   使用 ‘ ’或是””” “”“或是”” “”标识</p><p>   其中，”””可以跨行使用</p><p>   还是和其他语言类似，还是有一些特殊的用法……:</p><blockquote><p>常规的用法中:’curry &#x3D; lambda f : lambda x : lambda y:f(x,y)’只是普通的字符串<br/>但是可以使用exec语法来执行字符串中的内容</p></blockquote><pre><code class="hljs">  in put:     exec(&#39;curry = lambda f : lambda x : lambda y:f(x,y)&#39;)     curry(add)(3)(4)  out put:     7</code></pre><p>字符串的一些特性:</p><blockquote><p>可以用类似列表的方法来操作字符串:</p></blockquote><pre><code class="hljs">  in put:     city = &#39;GuanDong&#39;     city[3]     len(city)  out put:      &#39;n&#39;      8</code></pre><blockquote><p>还有些更方便的用法,如果想查找字符串内是否包含某些值:</p></blockquote><pre><code class="hljs">  in put:     &#39;C++&#39;in &#39;C++ is the best language&#39;     &#39;C++&#39;in &#39;Python is the best language&#39;</code></pre><blockquote><p>in函数使用时，若是查找字符串则可以查找连续的字母，但若是在数组中，则只能查找一个元素:</p></blockquote><pre><code class="hljs">     234 in [1,2,3,4,5]     [2,3,4] in [1,2,3,4,5]</code></pre><br>     <pre><code class="hljs">  out put:      true      false      false      false </code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/year/01/17/hello-world/"/>
    <url>/year/01/17/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
