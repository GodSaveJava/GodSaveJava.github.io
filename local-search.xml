<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>&#39;算法学习&#39;</title>
    <link href="/year/02/09/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/year/02/09/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本篇用于记录刷力扣时值得参考的算法题，主语言为C++</p></blockquote><h2 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历  "></a>二叉树的中序遍历  <br/></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++">**<br> * Definition <span class="hljs-keyword">for</span> a binary tree node.<br> * <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br> *     <span class="hljs-type">int</span> val;<br> *     TreeNode *left;<br> *     TreeNode *right;<br> *     <span class="hljs-built_in">TreeNode</span>() : <span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br> *     <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br> *     <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x, TreeNode *left, TreeNode *right) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(left), <span class="hljs-built_in">right</span>(right) &#123;&#125;<br> * &#125;;<br> */<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root,vector&lt;<span class="hljs-type">int</span>&gt;&amp; res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)<br>        &#123;<br>            <span class="hljs-keyword">return</span>; <span class="hljs-comment">//当前节点为空的话跳出该次递归</span><br>        &#125;<br>        <span class="hljs-built_in">inorder</span>(root-&gt;left,res); <span class="hljs-comment">/*递归调用，将root指针指向当前节点的左子节点。当遇到最左边的子节点时</span><br><span class="hljs-comment">                                  再执行inorder的话，此时root指针会指向空，此时便会触发上面的if判断，</span><br><span class="hljs-comment">                                  跳出该次递归，返回上一层的递归。那么此时root便指向了最靠左的子节点</span><br><span class="hljs-comment">                                 */</span><br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val); <span class="hljs-comment">//root指针指向最左子节点后，将该节点的值压入容器res中</span><br>        <span class="hljs-built_in">inorder</span>(root-&gt;right,res); <span class="hljs-comment">//若该最左子节点他还有个右孩子的话，root便会指向它，再次执行上边的流程</span><br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>           vector&lt;<span class="hljs-type">int</span>&gt; res;  <span class="hljs-comment">//定义一个空的vector容器res</span><br>           <span class="hljs-built_in">inorder</span>(root,res);  <span class="hljs-comment">//从根节点开始执行递归</span><br>           <span class="hljs-keyword">return</span> res;   <span class="hljs-comment">//最后返回一个包含中序遍历的结果的res</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h2><blockquote><p>我觉得利用递归来建树这个思想很值得学习</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;<br>          <span class="hljs-keyword">if</span>(root1==<span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">//if用于判断是否到达叶节点，到达后跳出该层递归，返回上层节点。</span><br>                              <span class="hljs-comment">//还有一个作用是当A树的该节点为空，B树的该节点非空时,null + value = value，所以直接返回非空节点的值 </span><br>          &#123;<br>            <span class="hljs-keyword">return</span> root2;  <br>          &#125;<br>          <span class="hljs-keyword">if</span>(root2==<span class="hljs-literal">nullptr</span>)<br>          &#123;<br>            <span class="hljs-keyword">return</span> root1;<br>          &#125;<br>          <span class="hljs-keyword">auto</span> merged = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(root1-&gt;val + root2-&gt;val);  <span class="hljs-comment">//新建一个新节点，用于储存两个树的节点相加后的值</span><br>          merged-&gt;left = <span class="hljs-built_in">mergeTrees</span>(root1-&gt;left,root2-&gt;left);  <span class="hljs-comment">/*建立左子树部分，并且利用递归的方式创建左孩子的孩子节点</span><br><span class="hljs-comment">                                                                理解这一部分的递归调用很关键 */</span><br>          merged-&gt;right = <span class="hljs-built_in">mergeTrees</span>(root1-&gt;right,root2-&gt;right);<br>          <span class="hljs-keyword">return</span> merged;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结来说的运行逻辑是这样的:<br/><br>      创建一个merged节点(类型为结构体TreeNode,包含了val和left、right的指针)(这里的auto也很有意思，可以去了解一下)<br>      <br/>merged节点的值等于root1的值+root2的值<br>      <br/>目光聚焦到merged节点的左孩子,怎么得到它的值？再执行一遍mergeTrees函数！不过此时函数中的参数应该设置为root1,root2的左孩子<br>      <br/>如果还没到叶节点，那么这个递归会一直进行下去<br>      <br/>若到达了叶节点，说明这颗合成树的root-&gt;left-&gt;left-&gt;left……依旧构造完了<br>      <br/>叶子节点弹出递归栈，返回它的父节点，如果此时父节点的右孩子为非空的话，继续执行merged-&gt;right的递归<br>      <br/>反复的弹出递归栈…执行merged-&gt;right…….<br>      <br/></p></blockquote><blockquote><p>理解递归栈的调用和程序的执行顺寻很重要，比如执行递归调用时，当前的程序在什么位置？执行递归调用的话会回到什么位置？执行完递归后又会回到什么位置？这段代码会有助于理解递归栈的调用逻辑</p></blockquote><h2 id="for循环的简化"><a href="#for循环的简化" class="headerlink" title="for循环的简化"></a>for循环的简化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;prices.<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(prices[i]&lt;minbuy)<br>        &#123;<br>            minbuy = prices[i];  <span class="hljs-comment">//找到最小值</span><br>        &#125;<br>        profit = prices[i] - minbuy;<br>        <span class="hljs-keyword">if</span>(profit&gt;maxprofit)<br>        &#123;<br>            maxprofit = profit;  <span class="hljs-comment">//找到最大值</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>看起来就很冗余，可以用 : 来代替for循环中的条件，并且最大最小值可与用max(a,b),min(a,b)来完成</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:prices) <span class="hljs-comment">//等于:for(int j = 0;j&lt;prices.size();j++)    i = price[j]</span><br>   &#123;   <br>       minbuy = <span class="hljs-built_in">min</span>(minbuy,i);  <span class="hljs-comment">//比if判断要简洁多了</span><br>       maxprofit = <span class="hljs-built_in">max</span>(maxprofit,i-minbuy);<br>     <br>   &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>&#39;CS61A学习历程（2）&#39;</title>
    <link href="/year/01/26/CS61A%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B%EF%BC%882%EF%BC%89/"/>
    <url>/year/01/26/CS61A%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B%EF%BC%882%EF%BC%89/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CS61A 学习历程</title>
    <link href="/year/01/24/CS61A-%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/"/>
    <url>/year/01/24/CS61A-%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="范围-range"><a href="#范围-range" class="headerlink" title="范围(range)"></a>范围(range)</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code class="hljs">range(startNum,endNum-1)</code></pre><blockquote><p><em>是的，这看起来有些奇怪,但请切记endNum-1这一回事!!<br/>如果你想要范围1~10的话，请输入:range(1,11)而不是range(1,10)!!!</em></p></blockquote><p>例如:  </p><pre><code class="hljs">in put :         range(1,3)out put :   [1,2]</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="range可以搭配数组一起使用"><a href="#range可以搭配数组一起使用" class="headerlink" title="range可以搭配数组一起使用:"></a>range可以搭配数组一起使用:</h4><pre><code class="hljs">   odd = [2,4,6,8,10,12]in put :  [odd[i] for i in  range(1,3)]   //或是  odd[1:3]</code></pre><blockquote><p>这里提到了for的一个用法，该语句意思是依次提取列表odd中第i个值，i的值分别是范围1~2(即提取odd[1],odd[2])<br/>另外，记得列表是从第0个开始的</p></blockquote><pre><code class="hljs">out put:  [4,6]</code></pre><h4 id="搭配函数使用"><a href="#搭配函数使用" class="headerlink" title="搭配函数使用:"></a>搭配函数使用:</h4><pre><code class="hljs">in put:   max(range(5)) 等同于 max(0,1,2,3,4)out put:    4这里提到了max函数,还有个更好玩的特性：in put:    max(range(10),key = lamba x: 7 -(x-4)*(x-2))      //意思是x的取值范围为0~9,key等于关于x的表达式7 -(x-4)*(x-2)，x取所有范围的值计算后的最大值    //(lamba x: 7 -(x-4)*(x-2)) (3) = 8    //(lamba x: 7 -(x-4)*(x-2)) (2) = 7    //(lamba x: 7 -(x-4)*(x-2)) (4) = 7out put:    3</code></pre><h3 id="一些特性"><a href="#一些特性" class="headerlink" title="一些特性"></a>一些特性</h3><p>若不声明startNum,则默认为从0开始</p><p>若不声明endNum,则默认范围至末尾为止</p><pre><code class="hljs">in put :  odd[1:3]  odd[:3]  odd[1:]  odd[:]out put:  [4,6]  [2,4,6]  [4,6,8,10,12]  [2,4,6,8,10,12]</code></pre><h1 id="判断-bool"><a href="#判断-bool" class="headerlink" title="判断(bool)"></a>判断(bool)</h1><p>   和其他语言类似，具体用法不再赘述，值得一提的是，Py里bool函数有些有趣的用法:</p><pre><code class="hljs"> in put:    [x&lt;5 for x in range(5)]    [x&lt;4 for x in range(5)] out put:     [ture,ture,ture,ture,ture,ture]     [ture,ture,ture,ture,ture,false]</code></pre><h1 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串(string)"></a>字符串(string)</h1><p>   使用 ‘ ’或是””” “”“或是”” “”标识</p><p>   其中，”””可以跨行使用</p><p>   还是和其他语言类似，还是有一些特殊的用法……:</p><blockquote><p>常规的用法中:’curry &#x3D; lambda f : lambda x : lambda y:f(x,y)’只是普通的字符串<br/>但是可以使用exec语法来执行字符串中的内容</p></blockquote><pre><code class="hljs">  in put:     exec(&#39;curry = lambda f : lambda x : lambda y:f(x,y)&#39;)     curry(add)(3)(4)  out put:     7</code></pre><p>字符串的一些特性:</p><blockquote><p>可以用类似列表的方法来操作字符串:</p></blockquote><pre><code class="hljs">  in put:     city = &#39;GuanDong&#39;     city[3]     len(city)  out put:      &#39;n&#39;      8</code></pre><blockquote><p>还有些更方便的用法,如果想查找字符串内是否包含某些值:</p></blockquote><pre><code class="hljs">  in put:     &#39;C++&#39;in &#39;C++ is the best language&#39;     &#39;C++&#39;in &#39;Python is the best language&#39;</code></pre><blockquote><p>in函数使用时，若是查找字符串则可以查找连续的字母，但若是在数组中，则只能查找一个元素:</p></blockquote><pre><code class="hljs">     234 in [1,2,3,4,5]     [2,3,4] in [1,2,3,4,5]</code></pre><br>     <pre><code class="hljs">  out put:      true      false      false      false </code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/year/01/17/hello-world/"/>
    <url>/year/01/17/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
