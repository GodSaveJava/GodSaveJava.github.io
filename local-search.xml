<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>排序算法思想及实现</title>
    <link href="/year/03/03/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <url>/year/03/03/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><blockquote><p>算法思想是从长度为Length列表的第一个元素开始向后遍历，若相邻(当前遍历元素的右边)的元素的值小于当前<br/><br/><br>        遍历的元素，则交换两个数的位置，如此反复直到遍历至表尾，此时完成了第一轮遍历。反复执行Length-1轮<br/><br/><br>        时间复杂度: O(n²) 因为要执行两层循环<br/><br/><br>        空间复杂度: O(1) 不需要额外的空间<br/><br/><br>        优点: 好理解，不需要额外空间开销<br/><br/><br>        缺点: 慢，不适合处理大规模数据<br/><br/></p></blockquote><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">void <span class="hljs-keyword">Bubble_Sort(vector&lt;int&gt;&amp; </span>List)<br>&#123;<br>int <span class="hljs-keyword">swap;</span><br><span class="hljs-keyword"></span>for (int i = <span class="hljs-number">0</span><span class="hljs-comment">;i &lt; size(List) - 1;i++)</span><br>&#123;<br>for (int <span class="hljs-keyword">j </span>= <span class="hljs-number">0</span><span class="hljs-comment">;j &lt; size(List)-1;j++)</span><br>&#123;<br>if (List[<span class="hljs-keyword">j] </span>&gt; List[<span class="hljs-keyword">j+1])</span><br><span class="hljs-keyword"></span>&#123;<br><span class="hljs-keyword">swap </span>= List[<span class="hljs-keyword">j];</span><br>List[<span class="hljs-keyword">j] </span>= List[<span class="hljs-keyword">j+1];</span><br><span class="hljs-keyword"></span>List[<span class="hljs-keyword">j+1] </span>= <span class="hljs-keyword">swap;</span><br><span class="hljs-keyword"></span>&#125;<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><blockquote><p>选择排序</p><p>&ensp;思想:<br/><br>  &ensp;将数据分为已排序和未排序两个部分，在开始前，已排序部分为空，未排序部分为整个数组</p><p>&ensp;此时从未排序的部分中找到最小的值，与未排序部分的第一个元素交换位置。交换后该位置便为已排序部分，未排序部分的起始位置向后移一位。如此反复逐渐扩大已排序部分的范围。</p><p>&ensp;例如:a&lt;b&lt;c&lt;d  ,有列表元素[c,a,d,b]<br/><br>&ensp;未排序(初始):c,a,d,b<br/><br>&ensp;交换位置:[a,c,d,b]<br/><br>  &ensp;已排序:a<br/><br>&ensp;未排序;c,d,b<br>….</p><p>&ensp;时间复杂度: 无论如何都是O(n²)，即使是初始便是有序的数组也要从头到尾执行一遍<br/><br>&ensp;空间复杂度: O(1)</p><p>&ensp;稳定性: 不稳定(相同大小不同前后顺序的元素，在排序后前后位置可能会发生改变)</p></blockquote><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Selection_Sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; list)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">size</span>(list)<span class="hljs-number">-1</span>;i++)<br>&#123;   <br><span class="hljs-type">int</span> min = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=i<span class="hljs-number">+1</span>;j&lt;<span class="hljs-built_in">size</span>(list);j++)<br>&#123;<br><span class="hljs-keyword">if</span> (list[j] &lt; list[min])<br>&#123;<br>min = j;<br>&#125;<br>&#125;<br><span class="hljs-built_in">swap</span>(list[i], list[min]);<br>&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习</title>
    <link href="/year/02/27/Linux%E5%AD%A6%E4%B9%A0/"/>
    <url>/year/02/27/Linux%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>首先要明白绝对路径和相对路径<br/><br>  绝对路径:相对于根目录的路径<br/><br>  相对路径:相对于当前目录的路径<br/><br>  <br/><br>  另外在输入时按tab键可以实现自动补全（若是有多个结果则会罗列出所有结果)</p></blockquote><h1 id="1-常用的指令"><a href="#1-常用的指令" class="headerlink" title="1.常用的指令:"></a>1.常用的指令:</h1><h2 id="1-1-pwd-打印路径"><a href="#1-1-pwd-打印路径" class="headerlink" title="1.1 pwd 打印路径"></a>1.1 pwd 打印路径</h2><p>   用于打印当前所在文件夹的路径</p><h2 id="1-2-cd-进入文件"><a href="#1-2-cd-进入文件" class="headerlink" title="1.2 cd 进入文件"></a>1.2 cd 进入文件</h2><p>   进入文件夹的指令:cd XXX</p><h2 id="1-3-mkdir-创建目录-make-directories"><a href="#1-3-mkdir-创建目录-make-directories" class="headerlink" title="1.3 mkdir 创建目录 -make directories"></a>1.3 mkdir 创建目录 -make directories</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在当前目录下创建XXX子目录</span><br>  <br>  <span class="hljs-built_in">mkdir</span> XXX<br><br><span class="hljs-comment"># 一次性创建多层目录</span><br>  <br>  <span class="hljs-built_in">mkdir</span> -p a/b/c<br><br><span class="hljs-comment"># 一次性创建多个目录</span><br>  <br>  <span class="hljs-built_in">mkdir</span> a b c<br></code></pre></td></tr></table></figure><h2 id="1-4-touch-创建文件"><a href="#1-4-touch-创建文件" class="headerlink" title="1.4 touch  创建文件"></a>1.4 touch  创建文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在当前目录下创建linux.txt文件</span><br><br>  <span class="hljs-built_in">touch</span> linux.txt<br><br><span class="hljs-comment"># 在上级目录下创建linux文件(创建与当前目录同级的文件)</span><br><br>  <span class="hljs-built_in">touch</span> ../linux<br><br><span class="hljs-comment"># 在home/bing/目录下创建linux文件(在指定路径下创建)</span><br><br>  <span class="hljs-built_in">touch</span> /home/bing/linux<br><br><span class="hljs-comment"># touch可用于创建多个文件，例如创建file file.txt两个文件(不指定文件后缀名则创建的是文件夹，指定后缀则是创建相应的文件)</span><br>  <br>  <span class="hljs-built_in">touch</span> file file.txt<br></code></pre></td></tr></table></figure><h2 id="1-5-ls-展现结构"><a href="#1-5-ls-展现结构" class="headerlink" title="1.5 ls 展现结构"></a>1.5 ls 展现结构</h2><p>  展现目录结构(当前目录所有的文件和文件夹)<br>  用例:<br/></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 展现当前目录</span><br>  <br>  <span class="hljs-built_in">ls</span>(也可写作: <span class="hljs-built_in">ls</span> ./)<br><br><span class="hljs-comment"># 展现上一级目录</span><br>  <br>  <span class="hljs-built_in">ls</span> ../<br><br><span class="hljs-comment"># 展现绝对路径</span><br>  <br>  <span class="hljs-built_in">ls</span> /home<br><br><span class="hljs-comment"># 展现根目录</span><br>  <span class="hljs-built_in">ls</span> /<br><br><span class="hljs-comment"># 列出指定路径下的文件/文件夹的名称，并以指定的格式进行显示</span><br>  语法:<span class="hljs-built_in">ls</span> 选项 路径<br>  <span class="hljs-built_in">ls</span> -lah /home<br>     解释:<br>         -l:表示list,表示以列表进行展示<br>         -a:表示显示所有的文件/文件夹（包含隐藏文件/文件夹)<br>         -h:表示以可读性较高的形式显示<br></code></pre></td></tr></table></figure><h2 id="1-6-rm-删除文件-目录"><a href="#1-6-rm-删除文件-目录" class="headerlink" title="1.6 rm 删除文件&#x2F;目录"></a>1.6 rm 删除文件&#x2F;目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 删除当前路径的文件</span><br>  <br>  <span class="hljs-built_in">rm</span> XXX<br><br><span class="hljs-comment"># 删除指定路径下的文件</span><br>  <br>  <span class="hljs-built_in">rm</span> /XX/XX/XXX<br><br><span class="hljs-comment"># 删除目录</span><br>  <br>  <span class="hljs-built_in">rm</span> -rf XXX<br>  <span class="hljs-built_in">rm</span> -rf /XX/XXX/XXX (支持绝对路径下删除)<br></code></pre></td></tr></table></figure><h2 id="1-7-cp-复制文件-文件夹到指定路径"><a href="#1-7-cp-复制文件-文件夹到指定路径" class="headerlink" title="1.7 cp 复制文件&#x2F;文件夹到指定路径"></a>1.7 cp 复制文件&#x2F;文件夹到指定路径</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 复制文件到指定路径</span><br>  语法: <span class="hljs-built_in">cp</span> 被复制的文件路径 文件被复制到的路径<br>  <br>  <span class="hljs-built_in">cp</span> /home/user/XXX  XXX/<br>  <br><span class="hljs-comment"># 复制文件夹到指定路径</span><br>  语法: <span class="hljs-built_in">cp</span> -r 被复制的文件夹路径 文件夹要复制到的路径<br> <br>  <span class="hljs-built_in">cp</span> -r XXX/ XXX/<br></code></pre></td></tr></table></figure><h2 id="1-8-mv-移动-重命名文件"><a href="#1-8-mv-移动-重命名文件" class="headerlink" title="1.8 mv 移动&#x2F;重命名文件"></a>1.8 mv 移动&#x2F;重命名文件</h2><blockquote><p>注意区分‘移动’和‘复制’的区别</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 移动文件</span><br>  语法: <span class="hljs-built_in">rm</span> 需要移动的文件的路径 移动的目的路径/<br>  <br>  <span class="hljs-built_in">rm</span> a b/<br>  <span class="hljs-built_in">rm</span> a ./  <span class="hljs-comment">#将路径a上的文件移动到根目录下</span><br><br><span class="hljs-comment"># 修改名称</span><br>  语法: <span class="hljs-built_in">rm</span> 文件名 文件名 <br><br>  <span class="hljs-built_in">rm</span> a b <span class="hljs-comment">#将当前文件夹下的文件a更名为b (注意:更名不需要输入路径，需先cd进入当前文件夹，才可对该文件夹下的文件进行更名操作)</span><br></code></pre></td></tr></table></figure><h1 id="使用vim及g-进行程序设计与编译"><a href="#使用vim及g-进行程序设计与编译" class="headerlink" title="使用vim及g++进行程序设计与编译"></a>使用vim及g++进行程序设计与编译</h1><h2 id="vim的使用"><a href="#vim的使用" class="headerlink" title="vim的使用 "></a>vim的使用 <br/></h2><blockquote><p>首先需要先cd进入对应的文件目录</p></blockquote><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vim"># 创建/打开文件<br>   <br>  <span class="hljs-keyword">vim</span> 文件名/文件路径(不预先<span class="hljs-keyword">cd</span>的话)   //终端会进入<span class="hljs-keyword">vim</span>编译器中，并且创建该文件，若该文件已存在则是打开该文件<br><br># 编写程序<br>   <br>  <span class="hljs-keyword">vim</span>编译器有分普通模式、末行模式和插入模式<br>  模式切换:<br>    <span class="hljs-number">1</span>.插入模式下按 Esc键进入普通模式<br>    <span class="hljs-number">2</span>.普通模式下输入 ：进入末行模式<br>    <span class="hljs-number">3</span>.插入模式和末行模式不能直接切换<br>  区别:<br>    普通模式主要操作：删除、复制、粘贴<br>    编辑模式主要操作：编辑文本<br>    末行模式主要操作：退出保存<br></code></pre></td></tr></table></figure><h2 id="vim-常用操作"><a href="#vim-常用操作" class="headerlink" title="vim 常用操作"></a>vim 常用操作</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-comment"># 在末行模式下:</span><br>  <span class="hljs-symbol">:w</span> 保存文件<br>    <br>  <span class="hljs-symbol">:q</span> 退出文件<br> <br>  <span class="hljs-symbol">:wq</span> 保存并退出文件<br> <br>  <span class="hljs-symbol">:w!</span> 强制保存文件<br> <br>  <span class="hljs-symbol">:q!</span>强制退出文件<br> <br>  <span class="hljs-symbol">:wq!</span> 强制保存并退出文件<br> <br>  <span class="hljs-symbol">:w</span> <span class="hljs-number">1</span>.txt 将文件另存到<span class="hljs-number">1</span>.txt <br> <br>  <span class="hljs-symbol">:</span><span class="hljs-number">1</span>,<span class="hljs-number">3</span> w <span class="hljs-number">1</span>.txt 将<span class="hljs-number">1</span><span class="hljs-number">-3</span>行内容另存到<span class="hljs-number">1</span>.txt  <br> <br>  <span class="hljs-symbol">:r</span> <span class="hljs-number">2</span>.txt 将<span class="hljs-number">2</span>.txt文件内容写入到该文件光标所在行中<br> <br>  <span class="hljs-symbol">:</span><span class="hljs-number">5</span> r <span class="hljs-number">2</span>.txt 将<span class="hljs-number">2</span>.txt文件内容写入到该文件第<span class="hljs-number">5</span>行后<br></code></pre></td></tr></table></figure><h2 id="使用g-编译文件"><a href="#使用g-编译文件" class="headerlink" title="使用g++编译文件"></a>使用g++编译文件</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 编译操作</span><br>  <br>  g++ 文件名<span class="hljs-params">(带后缀)</span> -o 输出的文件名  <span class="hljs-string">//</span>执行后在相应的路径下生成一个可执行文件<br><br><span class="hljs-comment"># 执行文件</span><br>  可以用<span class="hljs-keyword">ls</span>查看当前目录下的文件，绿色文件名的文件即为可执行文件<br>   <br>  <span class="hljs-string">./</span>可执行文件名  <span class="hljs-string">//</span>这里的<span class="hljs-string">./</span>表示当前目录<br><br><span class="hljs-comment"># 编译带调试信息的·1可执行文件</span><br><br>  g++ -g 文件名 -o 输出文件名  <span class="hljs-string">//</span>产生能被GDB使用的调试信息，以调试程序<br><br><span class="hljs-comment"># 指定编译标准</span><br><br>  g++ -std=标准 文件名<br>  例 g++ -std=c++11 xxx.cpp<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>&#39;算法学习&#39;</title>
    <link href="/year/02/09/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/year/02/09/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本篇用于记录刷力扣时值得参考的算法题，主语言为C++</p></blockquote><h2 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历  "></a>二叉树的中序遍历  <br/></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++">**<br> * Definition <span class="hljs-keyword">for</span> a binary tree node.<br> * <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br> *     <span class="hljs-type">int</span> val;<br> *     TreeNode *left;<br> *     TreeNode *right;<br> *     <span class="hljs-built_in">TreeNode</span>() : <span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br> *     <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br> *     <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x, TreeNode *left, TreeNode *right) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(left), <span class="hljs-built_in">right</span>(right) &#123;&#125;<br> * &#125;;<br> */<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root,vector&lt;<span class="hljs-type">int</span>&gt;&amp; res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)<br>        &#123;<br>            <span class="hljs-keyword">return</span>; <span class="hljs-comment">//当前节点为空的话跳出该次递归</span><br>        &#125;<br>        <span class="hljs-built_in">inorder</span>(root-&gt;left,res); <span class="hljs-comment">/*递归调用，将root指针指向当前节点的左子节点。当遇到最左边的子节点时</span><br><span class="hljs-comment">                                  再执行inorder的话，此时root指针会指向空，此时便会触发上面的if判断，</span><br><span class="hljs-comment">                                  跳出该次递归，返回上一层的递归。那么此时root便指向了最靠左的子节点</span><br><span class="hljs-comment">                                 */</span><br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val); <span class="hljs-comment">//root指针指向最左子节点后，将该节点的值压入容器res中</span><br>        <span class="hljs-built_in">inorder</span>(root-&gt;right,res); <span class="hljs-comment">//若该最左子节点他还有个右孩子的话，root便会指向它，再次执行上边的流程</span><br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>           vector&lt;<span class="hljs-type">int</span>&gt; res;  <span class="hljs-comment">//定义一个空的vector容器res</span><br>           <span class="hljs-built_in">inorder</span>(root,res);  <span class="hljs-comment">//从根节点开始执行递归</span><br>           <span class="hljs-keyword">return</span> res;   <span class="hljs-comment">//最后返回一个包含中序遍历的结果的res</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h2><blockquote><p>我觉得利用递归来建树这个思想很值得学习</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;<br>          <span class="hljs-keyword">if</span>(root1==<span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">//if用于判断是否到达叶节点，到达后跳出该层递归，返回上层节点。</span><br>                              <span class="hljs-comment">//还有一个作用是当A树的该节点为空，B树的该节点非空时,null + value = value，所以直接返回非空节点的值 </span><br>          &#123;<br>            <span class="hljs-keyword">return</span> root2;  <br>          &#125;<br>          <span class="hljs-keyword">if</span>(root2==<span class="hljs-literal">nullptr</span>)<br>          &#123;<br>            <span class="hljs-keyword">return</span> root1;<br>          &#125;<br>          <span class="hljs-keyword">auto</span> merged = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(root1-&gt;val + root2-&gt;val);  <span class="hljs-comment">//新建一个新节点，用于储存两个树的节点相加后的值</span><br>          merged-&gt;left = <span class="hljs-built_in">mergeTrees</span>(root1-&gt;left,root2-&gt;left);  <span class="hljs-comment">/*建立左子树部分，并且利用递归的方式创建左孩子的孩子节点</span><br><span class="hljs-comment">                                                                理解这一部分的递归调用很关键 */</span><br>          merged-&gt;right = <span class="hljs-built_in">mergeTrees</span>(root1-&gt;right,root2-&gt;right);<br>          <span class="hljs-keyword">return</span> merged;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结来说的运行逻辑是这样的:<br/><br>      创建一个merged节点(类型为结构体TreeNode,包含了val和left、right的指针)(这里的auto也很有意思，可以去了解一下)<br>      <br/>merged节点的值等于root1的值+root2的值<br>      <br/>目光聚焦到merged节点的左孩子,怎么得到它的值？再执行一遍mergeTrees函数！不过此时函数中的参数应该设置为root1,root2的左孩子<br>      <br/>如果还没到叶节点，那么这个递归会一直进行下去<br>      <br/>若到达了叶节点，说明这颗合成树的root-&gt;left-&gt;left-&gt;left……依旧构造完了<br>      <br/>叶子节点弹出递归栈，返回它的父节点，如果此时父节点的右孩子为非空的话，继续执行merged-&gt;right的递归<br>      <br/>反复的弹出递归栈…执行merged-&gt;right…….<br>      <br/></p></blockquote><blockquote><p>理解递归栈的调用和程序的执行顺寻很重要，比如执行递归调用时，当前的程序在什么位置？执行递归调用的话会回到什么位置？执行完递归后又会回到什么位置？这段代码会有助于理解递归栈的调用逻辑</p></blockquote><h2 id="for循环的简化"><a href="#for循环的简化" class="headerlink" title="for循环的简化"></a>for循环的简化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;prices.<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(prices[i]&lt;minbuy)<br>        &#123;<br>            minbuy = prices[i];  <span class="hljs-comment">//找到最小值</span><br>        &#125;<br>        profit = prices[i] - minbuy;<br>        <span class="hljs-keyword">if</span>(profit&gt;maxprofit)<br>        &#123;<br>            maxprofit = profit;  <span class="hljs-comment">//找到最大值</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>看起来就很冗余，可以用 : 来代替for循环中的条件，并且最大最小值可与用max(a,b),min(a,b)来完成</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:prices) <span class="hljs-comment">//等于:for(int j = 0;j&lt;prices.size();j++)    i = price[j]</span><br>   &#123;   <br>       minbuy = <span class="hljs-built_in">min</span>(minbuy,i);  <span class="hljs-comment">//比if判断要简洁多了</span><br>       maxprofit = <span class="hljs-built_in">max</span>(maxprofit,i-minbuy);<br>     <br>   &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>&#39;CS61A学习历程（2）&#39;</title>
    <link href="/year/01/26/CS61A%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B%EF%BC%882%EF%BC%89/"/>
    <url>/year/01/26/CS61A%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B%EF%BC%882%EF%BC%89/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CS61A 学习历程</title>
    <link href="/year/01/24/CS61A-%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/"/>
    <url>/year/01/24/CS61A-%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="范围-range"><a href="#范围-range" class="headerlink" title="范围(range)"></a>范围(range)</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code class="hljs">range(startNum,endNum-1)</code></pre><blockquote><p><em>是的，这看起来有些奇怪,但请切记endNum-1这一回事!!<br/>如果你想要范围1~10的话，请输入:range(1,11)而不是range(1,10)!!!</em></p></blockquote><p>例如:  </p><pre><code class="hljs">in put :         range(1,3)out put :   [1,2]</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="range可以搭配数组一起使用"><a href="#range可以搭配数组一起使用" class="headerlink" title="range可以搭配数组一起使用:"></a>range可以搭配数组一起使用:</h4><pre><code class="hljs">   odd = [2,4,6,8,10,12]in put :  [odd[i] for i in  range(1,3)]   //或是  odd[1:3]</code></pre><blockquote><p>这里提到了for的一个用法，该语句意思是依次提取列表odd中第i个值，i的值分别是范围1~2(即提取odd[1],odd[2])<br/>另外，记得列表是从第0个开始的</p></blockquote><pre><code class="hljs">out put:  [4,6]</code></pre><h4 id="搭配函数使用"><a href="#搭配函数使用" class="headerlink" title="搭配函数使用:"></a>搭配函数使用:</h4><pre><code class="hljs">in put:   max(range(5)) 等同于 max(0,1,2,3,4)out put:    4这里提到了max函数,还有个更好玩的特性：in put:    max(range(10),key = lamba x: 7 -(x-4)*(x-2))      //意思是x的取值范围为0~9,key等于关于x的表达式7 -(x-4)*(x-2)，x取所有范围的值计算后的最大值    //(lamba x: 7 -(x-4)*(x-2)) (3) = 8    //(lamba x: 7 -(x-4)*(x-2)) (2) = 7    //(lamba x: 7 -(x-4)*(x-2)) (4) = 7out put:    3</code></pre><h3 id="一些特性"><a href="#一些特性" class="headerlink" title="一些特性"></a>一些特性</h3><p>若不声明startNum,则默认为从0开始</p><p>若不声明endNum,则默认范围至末尾为止</p><pre><code class="hljs">in put :  odd[1:3]  odd[:3]  odd[1:]  odd[:]out put:  [4,6]  [2,4,6]  [4,6,8,10,12]  [2,4,6,8,10,12]</code></pre><h1 id="判断-bool"><a href="#判断-bool" class="headerlink" title="判断(bool)"></a>判断(bool)</h1><p>   和其他语言类似，具体用法不再赘述，值得一提的是，Py里bool函数有些有趣的用法:</p><pre><code class="hljs"> in put:    [x&lt;5 for x in range(5)]    [x&lt;4 for x in range(5)] out put:     [ture,ture,ture,ture,ture,ture]     [ture,ture,ture,ture,ture,false]</code></pre><h1 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串(string)"></a>字符串(string)</h1><p>   使用 ‘ ’或是””” “”“或是”” “”标识</p><p>   其中，”””可以跨行使用</p><p>   还是和其他语言类似，还是有一些特殊的用法……:</p><blockquote><p>常规的用法中:’curry &#x3D; lambda f : lambda x : lambda y:f(x,y)’只是普通的字符串<br/>但是可以使用exec语法来执行字符串中的内容</p></blockquote><pre><code class="hljs">  in put:     exec(&#39;curry = lambda f : lambda x : lambda y:f(x,y)&#39;)     curry(add)(3)(4)  out put:     7</code></pre><p>字符串的一些特性:</p><blockquote><p>可以用类似列表的方法来操作字符串:</p></blockquote><pre><code class="hljs">  in put:     city = &#39;GuanDong&#39;     city[3]     len(city)  out put:      &#39;n&#39;      8</code></pre><blockquote><p>还有些更方便的用法,如果想查找字符串内是否包含某些值:</p></blockquote><pre><code class="hljs">  in put:     &#39;C++&#39;in &#39;C++ is the best language&#39;     &#39;C++&#39;in &#39;Python is the best language&#39;</code></pre><blockquote><p>in函数使用时，若是查找字符串则可以查找连续的字母，但若是在数组中，则只能查找一个元素:</p></blockquote><pre><code class="hljs">     234 in [1,2,3,4,5]     [2,3,4] in [1,2,3,4,5]</code></pre><br>     <pre><code class="hljs">  out put:      true      false      false      false </code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/year/01/17/hello-world/"/>
    <url>/year/01/17/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
